#include <reedGPU.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <math.h>
// Source file needs to be a text file, with the following parameters:
//<Columns> <Rows> 
//[Number of grains at each position, including the zero grains. Do not include the sink. This program assumes that the sink surrounds the rectangle. If you want sinks inside the rectangle, give a INT_MIN value for the sand grains]
int* file_extractor(char *file_name, int &h, int &v){
  FILE *file;
  file = fopen(file_name, "r");
  int z = 0;
  int x;
  fscanf(file, "%d", &h);
  fscanf(file, "%d", &v);
  h += 2;
  v += 2;
  int n = h*v;
  int* s = (int*)malloc(n*sizeof(int));
  while(fscanf(file,"%d",&x) != EOF){
    s[z]=x;
    z++;
  }
  fclose(file);
  return(s);

}
char* rgbDet(int s, int res){
  int r, g, b;
  b = s%res;
  s /= res;
  g = s%res;
  s /= res;
  r = s%res;
  char* fs =(char*)malloc(32*sizeof(char));
  sprintf(fs, "%d %d %d   ",r,g,b);
  return(fs);
}
void ppm(int* src, int h, int v, int n, int r, char* s){
  FILE* fp;
  int res = 30;
  char* fn = (char*)malloc(500);
  sprintf(fn,"/home/gpu/vgopalas/sand2/PPMOut/%s%06d.ppm",s,r);
  fp = fopen(fn, "w");
  if(fp ==NULL){
    printf("failure");
    exit(-1);
      }
  fprintf(fp,"P3\n%d %d\n%d",h,v, res);
  for(int i =0;i<n;i++){
    char* fsn =(char*)malloc(30*sizeof(char));
    if(i%60 == 0){
      fprintf(fp,"\n");
    }
    if(src[i]==0){
      fprintf(fp,"0 0 0   ");
    }
    else{ if(src[i]==1){
	sprintf(fsn,"%d 0 0   ",res);
	fprintf(fp,fsn);
      }
      else{ if(src[i]==2){
	  sprintf(fsn,"0 %d 0   ",res);
	  fprintf(fp,fsn);
	}
	else{ if(src[i]==3){
	    sprintf(fsn,"0 0 %d   ",res);

	    fprintf(fp, fsn);
	  }
	  else{
	    if(src[i] < 0){
	      sprintf(fsn,"%d %d %d   ",res, res, res);

	  fprintf(fp,fsn);
	  }
	    else{ char * fs = rgbDet(src[i],res);
	      fprintf(fp,fs);
	    }
	  }
	}
	  
      }}}
  fclose(fp);
}
	
int main(int argc, char **argv){

  if (argc < 3){
    printf("Usage: %s <Reps> <Source File> ", argv[0]);
    exit(-1);
  }

  long time = 0;
  int reps = atoi(argv[1]);
  int graph_h;
  int graph_v;
  int* sand_i = file_extractor(argv[2],graph_h,graph_v);
  int graph_n = graph_h * graph_v;
  rGcontext context;
  rGinit(&context);
  rGload(&context,"sand1.0.cl");
  
  rGmem dev_src;
  rGmem dev_dst;

  int *graph_src = (int *)rGmalloc(&context, "I", sizeof(cl_int)*graph_n,&dev_src);
  int *graph_dst = (int *)rGmalloc(&context, "O", sizeof(cl_int)*graph_n,&dev_dst);
  int si = 0;
  for(int u = 0; u <graph_n;u++){
    if(u <= graph_h||u%graph_h ==0 || (u+1)%graph_h ==0 || u>(graph_n-graph_h)){
      graph_src[u]= -1;
    }
    else{
    graph_src[u]=sand_i[si];
    si++;
    }
  }
  for(int j = 0; j<reps; j++){
    ppm(graph_src,graph_h,graph_v,graph_n,j,argv[0]);
  

  rGinitX(&context);
  printf("\n");

  rGnewX(&context,"run");
  rGargXmem(&context,dev_src);
  rGargXmem(&context,dev_dst);
  rGargXint(&context,graph_v);
  rGargXint(&context,graph_h);
  
  rGXid x = rGsubmitX(&context,graph_n,(atoi(argv[4])*atoi(argv[5])));

  rGwaitallX(&context);
  
  time += rGgettimeX(&context,x);
  for(int z = 0;z < graph_n;z++){
    graph_src[z]=graph_dst[z];
  }
  
  }
  ppm(graph_src,graph_h,graph_v,graph_n,reps,argv[0]);

  printf("%s \t%lu\n",argv[0],time);

}
